<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[怪兽说]]></title>
  <link href="http://blog.monstersay.cn/atom.xml" rel="self"/>
  <link href="http://blog.monstersay.cn/"/>
  <updated>2015-02-12T13:16:44+08:00</updated>
  <id>http://blog.monstersay.cn/</id>
  <author>
    <name><![CDATA[窥基／无柳无酒／黑灯瞎火]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[王强讲话]]></title>
    <link href="http://blog.monstersay.cn/blog/2015/01/29/wang-qiang-jiang-hua/"/>
    <updated>2015-01-29T19:53:54+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2015/01/29/wang-qiang-jiang-hua</id>
    <content type="html"><![CDATA[<p>今天王强老师和徐小平老师来阿里交流，幸亏手快抢了一张门票。徐小平老师基本上就和评价一样，是个老顽童，语速很快，很活泼，重点讲了公司治理，当中扯淡也挺多。王强老师上场后，一看就有学者风度，果然是当年做班长的，先谈人生哲学，再谈投资哲学，听完后很有启发，讲话的几个关键点在这里简单记录一下。</p>

<ul>
<li>先谈了一下容格的人生曲线理论，简而言之人生是一条抛物线。王老师认为人生是波动曲线，平庸和精彩的区别在于有些人死了以后波动就停止了，而有些人的波动一直在延续。</li>
<li>创业是什么，就是你有一个梦，如果大家都认同你这个梦，愿意融合到你这个梦里来，就可以成功了。</li>
<li>商业计划书没什么用，关键看团队是不是靠谱，没有领域专业知识就算了。天使轮也不看数字，梦是无法审计的。</li>
<li>承担坏的结果不是最痛苦的，面向未来的不确定进行选择是最痛苦的。想创业的话必须放弃眼前能看到的利益。</li>
<li>空想行业趋势和夕阳朝阳行业都是扯淡。抓住人们的刚需，解决大家的痛点他们就会投。真格基金去年投了北京一个做殡葬的startup，创始人是清华的~~~详情见<a href="http://www.biian.com/bzfw/71.html%E3%80%82">http://www.biian.com/bzfw/71.html%E3%80%82</a></li>
<li>作为startup的创始人，胸怀一定要大，你的胸怀决定了你能招到什么样的人，不能有老子天下第一的思想。用行政手段建立起来的权威是不可靠的，当你招了第一个下属或合伙人后，就必须重新树立自己的权威。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bugs: 优化要小心]]></title>
    <link href="http://blog.monstersay.cn/blog/2015/01/22/bug-optimization/"/>
    <updated>2015-01-22T10:33:35+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2015/01/22/bug-optimization</id>
    <content type="html"><![CDATA[<p>最近某个移动客户端发布新版本后有新用户反映安装后经常出现随机接口请求错误，经过日志排查是某些请求过于频繁导致后台暂时屏蔽。但是为什么会导致如此频繁的请求呢？记得开发同学们信誓旦旦的拍着胸脯说这块代码逻辑没改过啊～～～还是老规矩代码说话，把当前版本的git提交日志拉出来，好吧，相关代码有个优化&hellip;呃，真的只是优化吗？让我们先来看一下优化后的伪代码。</p>

<!--more-->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">dataAdapter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataAdapter</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">onMessageReceived</span><span class="o">(</span><span class="n">Result</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">((</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">getCount</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">receiveMessage</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>仔细分析一下代码问题就来了，对于老的已经有消息的用户，这段代码没有问题，但是对于新安装用户，服务端一条消息没有，那么问题就来了。当传入的result的count为0，调用receiveMessage向服务端请求，返回的result的count还是为0，结果就陷入了死循环，你丫好歹加个重试次数限制呢。再来看一下所谓优化前的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">void</span> <span class="nf">onMessageReceived</span><span class="o">(</span><span class="n">Result</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">dataAdapter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">dataAdapter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataAdapter</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">((</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">getCount</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">receiveMessage</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在原来的代码里，仅当dataAdapter没有初始化的时候，也就是系统第一次初始化的时候，会尝试重新向服务器请求一次信息，查看receiveMessage代码可以发现，第一次请求是读取本地缓存，可能会因为各种原因返回的count是0。初始化完成之后如果再取到count为0的情况，有可能是网络不好，用户手动刷新一下就好了，不影响正常使用。</p>

<p>事后沟通因为开发认为dataAdaper的初始化应该放到init中会比较清晰，结果没有正确解读原有代码的逻辑。所以没事不要随便优化，做优化之前一定要先写好单元测试，不然改完之后，哼哼！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[互联网招聘黑话]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/10/16/hu-lian-wang-zhao-pin-hei-hua/"/>
    <updated>2014-10-16T09:25:26+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/10/16/hu-lian-wang-zhao-pin-hei-hua</id>
    <content type="html"><![CDATA[<p>在水木上看到转的。</p>

<ul>
<li>期权激励拿到手软 &ndash;> 希望能弥补你看到基本工资后的脚软</li>
<li>有活力的技术团队 &ndash;> 团队平均工作经验&lt;1年</li>
<li>千亿市场的探索者 &ndash;> 目前尚没看清具体市场在哪</li>
<li>扁平化管理 &ndash;> 公司还没招到HR</li>
<li>典型欧美创业工作环境 &ndash;> 办公室现处于毛坯房状态</li>
<li>新技术+新方向+新团队 &ndash;> 嗯，目前这三样都没有</li>
<li>直进核心团队 &ndash;> 公司尚未设置非核心团队岗</li>
<li>全方位成长机会 &ndash;> 你有很大机会成为外卖超人</li>
<li>提供各种福利 &ndash;> 每样细说咱就伤感情了</li>
<li>提供住宿、班车及两餐 &ndash;> 每周提供数小时时间与家人团聚</li>
<li>底薪+岗位绩效+职称奖+管理绩效+提成+五险 &ndash;> 和在一块您看看够不够付这个月房租</li>
<li>加入我们，给你足够大的发展空间！ &ndash;> 目前公司规模&lt;10人</li>
<li>大牛云集 &ndash;> 我司属牛的同事比较多</li>
<li>公司计划短期内上市 &ndash;> 您也知道计划一般赶不上变化</li>
<li>徘徊在牛A和牛C之间一群人！ &ndash;> 永不止步，从来没在牛B上停驻过</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分层自动化测试]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/10/14/fen-ceng-zi-dong-hua-ce-shi/"/>
    <updated>2014-10-14T15:47:51+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/10/14/fen-ceng-zi-dong-hua-ce-shi</id>
    <content type="html"><![CDATA[<p>工作多年以来发现很多团队对自动化测试的理解就是写脚本，单元测试就是用XUnit框架写脚本。团队话费了大量精力去写自动化脚本但取得的实际价值确不容乐观，但很多人乐此不彼，觉得写代码就是白盒测试，是高大上的体现。其实这完全是个误区，首先我们看下白盒测试的定义：白盒测试（white-box testing）又称透明盒测试（glass box testing）、结构测试（structural testing）等，软件测试的主要方法之一，也称结构测试、逻辑驱动测试或基于程序本身的测试。测试应用程序的内部结构或运作，而不是测试应用程序的功能（即黑盒测试）。所以说我们平时写的大量功能测试脚本也属于黑盒测试的范畴。另外先强调一点，不管黑盒测试还是白盒测试，手工测试还是自动化测试，都属于革命工作分工不同，没有高低贵贱的区别，能发现bug，能保证产品按时发布，用户满意就是硬道理。</p>

<!--more-->


<p>先来谈谈我在工作中看到的自动化测试的误区：</p>

<ul>
<li>自动化测试脚本在完成后因为产品更新导致大量测试用例失效，由于团队忙于新功能开发，当失效的用例积累越来越多时，这些测试用例就慢慢失去维护。如果开发这些用例同学在的时候可能还好办，看一眼就知道是用例过期还是真有bug，可是当新同学接手的时候就迷茫了。记得刚进入微软我们团队接手一个项目的时候，跑一轮测试有5000个左右的用例，每次都有几百个随机错误，最后花了7个人近半年时间才清理干净。对于大多数团队来说是不会有如此奢侈的资源的。</li>
<li>大量的自动化测试脚本没有发现问题，上线后仍然问题不断。在测试中我们主要针对正常流程进行测试，但是在线上出故障的都是非正常流程，而在测试环境里由于种种限制，我们很难模拟服务请求失败，数据库访问异常，队列数据丢失，磁盘失效等等各种小概率异常。</li>
<li>代码质量问题严重。很多人写的单元测试只是构造一个输入然后检查返回值，结果是测试通过了但是问题却遗漏了。之前抽查某项目代码的时候发现这样一个问题：一个函数对它的输入做了处理后把结果写数据库，只要写成功了就返回true，反之则false。自动化脚本每次运行都通过，貌似皆大欢喜，但是问题来了，处理后写入数据库的内容正确吗？分析代码后发现对输入处理的逻辑有问题，写入数据库的内容本身就有问题。</li>
<li>重复轮子制造。大量的团队都在开发自己的自动化测试框架，实际上只是对各种开源框架进行裁剪完善。面试的时候经常有人说自动化测试经验丰富，一问就是开发某某自动化测试框架，再问产品测试的细节就很茫然了。其实对于大多数公司来说，开源的产品已经够用了，测试框架本身并不能提高产品质量。</li>
</ul>


<p>下面在谈分层测试之前先复习一下几个名词：</p>

<ul>
<li>单元测试：开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试是用于判断某个特定条件（或者场景）下某个特定函数的行为。</li>
<li>集成测试：也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求（如根据结构图〕组装成为子系统或系统，进行集成测试。实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。程序在某些局部反映不出来的问题，在全局上很可能暴露出来，影响功能的实现。</li>
<li>系统测试：将需测试的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素及环境结合在一起测试。在实际运行(使用)环境下，对计算机系统进行一系列的组装测试和确认测试。系统测试的目的在于通过与系统的需求定义作比较，发现软件与系统定义不符合或与之矛盾的地方。</li>
</ul>


<p>另外我们还要牢记一个概念：bug发现得越早修复成本越低。这里有个惨痛的教训，当年在fix了一个ADO的bug之后由于代码评审的一个失误，用户在运行了2年之后发现存在内存泄露，虽然修复很容易，加一行代码释放资源就解决了，但是沟通成本，修复和验证投入的人力成本，客户的信任成本等综合起来就非常可观了。</p>

<p>现在我们来看自动化测试如何分层（从低到高）：</p>

<ul>
<li>单元测试：开发人员在实现完代码之后或者在重构代码之前编写单元测试，用来确保功能正确或者保持一致。在这一层，我们可以把测试做到很细的粒度。通过<a href="http://baike.so.com/doc/2249429.html">mock</a>框架（在这里推荐PowerMock，能有效支持静态和私有方法的mock，具体使用可以参考这个<a href="https://github.com/yingl/PowerMockDemo">例子</a>。）能模拟各种异常情况，大大降低测试的外部依赖，使得单元测试尽可能做到随时随地可以运行。另外根据程序模块的划分，单元测试本身可以继续分层。比如服务层会调用数据库访问层读写数据库，我们可以在数据库访问层检查SQL脚本是否正确，数据写入是否正确（曾经遇到过分库分表逻辑设计错误）。在服务层的测试用例编写时我们就可以假设数据库访问层是正确工作的，通过mock我们可以简化测试程序的配置和用例编写，比如模拟数据库访问失败抛出异常等场景，另外对于网络层的很多功能也能进行mock。一般来说，单元测试由开发同学负责实现，写单元测试的过程也是对自己代码进行检查的一个过程。通过代码层有效的单元测试，相当于我们把生产的零部件都做了一遍检测，可以进入下一层了。这一层也是自动化测试投入产出比最高的地方，代码变动带来的维护成本也最低。通过接入持续集成，可以及时有效的发现代码层的问题并完成修复。</li>
<li>集成测试：在每个零部件通过检测之后，我们可以把他们装配起来了，对每一个模块进行检测。在这个层面我们更关心输入输出功能是否正确，对于常见的错误场景能否正确处理。结合我厂实际经验来说，可以理解成代码部署到日常环境后，通过直接访问HSF或者MTOP服务，在这里我们只关心对于输入能否有正确的响应，至于一些比较难模拟的错误场景，因为我们在单元测试里通过mock进行了覆盖，所以在这里不用过于操心，除非有特别需求我们再做特别处理。这一层应当是测试人员大展身手的地方，我们不需要了解代码的细节，但是我们对系统的结构，模块之间关系等等的理解充分体现你的测试代码里了。至于XUnit框架，它只是一个框架，方便我们组织测试代码而已。</li>
<li>系统测试：这个级别的测试是最接近用户实际场景的，同时也是自动化成本最高的。具体原因已经有很多论述了，在这里我就不细说了。所以在这一层做自动化测试，进可能能去实现那些已经标准化的流程，对于其它部分，通过手工测试或者一些辅助工具半自动化测试也未尝不是一种好的选择。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven-小技巧]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/09/29/maven-xiao-ji-qiao/"/>
    <updated>2014-09-29T09:34:53+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/09/29/maven-xiao-ji-qiao</id>
    <content type="html"><![CDATA[<p>最近在使用maven过程中发现一个问题，在更新了pom.xml文件后在idea中重新导入，但是相关的包还是没有找到。检查了一下发现jar包没有下载到本地。好吧，检查服务器，发现jar包是存在的，也能下载到本地。那问题就好办了，在本地用命令行方式安装就可以了。</p>

<p>mvn install:install-file -DgroupId=cn.monstersay.blog -DartifactId=blog-web -Dversion=1.0.0 -Dpackaging=jar -Dfile=blog-web-1.0.0-20140915.053502-20.jar</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bugs: 控制逻辑要小心]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/09/24/bug-control-flow/"/>
    <updated>2014-09-24T09:40:02+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/09/24/bug-control-flow</id>
    <content type="html"><![CDATA[<p>最近在给某项目写单元测试，话说这单元测试应该开发来写，但是项目紧张人手不足也就没这么多讲究了。遇到一个函数，看着逻辑很简单，不可能出错，但是一测就发现了问题。问题函数代码简化后如下：</p>

<!--more-->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">Info</span> <span class="nf">getInfoById</span><span class="o">(</span><span class="n">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Info</span> <span class="n">result</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">((</span><span class="n">id</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// 是否被初始化</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(!</span><span class="n">INIT</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// 初始化程序是否正在运行</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(!</span><span class="n">RUNNING</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">init</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// 直接查询数据库</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">result</span> <span class="o">=</span> <span class="n">infoDAO</span><span class="o">.</span><span class="na">getById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">Logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;...&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">infoDOMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>原理看着很简单，如果已经初始化，就直接从缓存map里查找并返回数据，否则检查是否有其它线程在运行init程序，没有的话先init初始化缓存然后从map里查找并返回数据并返回数据。可是单元测试一跑，问题立马暴露，当我直接查询数据库获得结果或者异常抛出后没有直接返回，而是去返回缓存里的结果。这会导致一个问题，当某个线程在初始化的时候，另一个线程去访问了一个没有完全初始化的缓存。要问这个bug怎么发现的？在单元测试里使用mock很容易模拟初始化的各种状态遍历各种控制路径。开发自己测试的时候只走了一条标准路径自然没有发现问题。修改后的代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">Info</span> <span class="nf">getInfoById</span><span class="o">(</span><span class="n">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">((</span><span class="n">id</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// 是否被初始化</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(!</span><span class="n">INIT</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// 初始化程序是否正在运行</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(!</span><span class="n">RUNNING</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">init</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// 直接查询数据库</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">infoDAO</span><span class="o">.</span><span class="na">getById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">DAOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">Logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;...&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">infoDOMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PowerMock简介]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/09/15/powermock-jie-shao/"/>
    <updated>2014-09-15T16:48:05+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/09/15/powermock-jie-shao</id>
    <content type="html"><![CDATA[<p>工作多年以来发现很多团队对自动化测试的理解就是写脚本，单元测试就是用XUnit框架写脚本。团队话费了大量精力去写脚本但取得的实际价值确不容乐观。比如在测试中我想测试数据库读写异常，网络请求返回特定的错误等等&hellip;</p>

<!--more-->


<p>以上这些想法如果通过正常手段去模拟会遇到很多困难，而且会导致测试对外部组件、环境有很强的依赖，还会导致代码难以维护。为了方便起见，我在单元测试的编写过程中选用了PowerMock框架来实现mock功能。</p>

<p>之所以选用PowerMock是因为它弥补了iMock, EasyMock和Mockito框架等的一个共同缺点：不支持静态，私有和final方法。具体使用的时候非常方便，因为PowerMock是对现有框架进行扩展，基本遵循相同的语法。我在github上放了一个<a href="https://github.com/yingl/PowerMockDemo">例子</a>，演示了几个常用的场景。</p>

<p>Maven配置：在pom.xml中添加以下引用，这里使用了基于Mockito的实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>    <span class="nt">&lt;groupId&gt;</span>org.powermock<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>powermock-api-mockito<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>1.5.5<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
</span><span class='line'><span class="nt">&lt;/dependency&gt;</span>
</span><span class='line'><span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>    <span class="nt">&lt;groupId&gt;</span>org.powermock<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>powermock-module-junit4<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>1.5.5<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
</span><span class='line'><span class="nt">&lt;/dependency&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>测试代码前添加如下注解，把你需要mock的类放在PrepareForTest里，不然运行时会报错。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@RunWith</span><span class="o">(</span><span class="n">PowerMockRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="nd">@PrepareForTest</span><span class="o">({</span><span class="n">DemoSpy</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoSpyTest</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《大话移动APP测试》书评]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/08/13/da-hua-yi-dong-app-ce-shi-shu-ping/"/>
    <updated>2014-08-13T10:10:04+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/08/13/da-hua-yi-dong-app-ce-shi-shu-ping</id>
    <content type="html"><![CDATA[<p><a href="http://book.douban.com/subject/25923638/">豆瓣链接</a></p>

<!--more-->


<p>Monkey可以称得上是中国移动互联网测试的先驱人物，今日做为同事为他的新书推荐，倍感荣幸。正如书名包含“大话”二字，所以你不要期望它是一本严肃的、学院派的技术书籍（据说2会是一本技术著作）。但是你如果是一个想进入移动测试领域的新人，又或者是一个想了解移动产品测试的产品经理、开发者、投资人，那么这本书是一本再好不过的教材。从针对专业技术人员的工具、框架、性能和自动化测试，到针对产品的用户体验测试，基本涵盖了移动产品测试的方方面面。另外作者还分享了大量亲身经历的案例，使得本书更具有可操作性，看完之后可以立刻投入到实际工作中去。除了严肃的技术内容，还有幽默风趣的吐槽和心灵鸡汤式的职业生涯指点。不管你式测试老兵还是行业新人，读完相信都能让你会心一笑，豁然开朗。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bugs: 小缓存大问题]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/08/12/bug-cache/"/>
    <updated>2014-08-12T20:40:05+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/08/12/bug-cache</id>
    <content type="html"><![CDATA[<p>具体业务细节不方便公开，但是这个问题警告我们在使用缓存的时候必须非常重视一致性问题。</p>

<p>首先来研究一下我们的缓存设计，我们选择了双机房双集群模式。也就是理论上说，每个机房都有一个独立的缓存集群，每次根据响应速度随机挑选一个比较快的集群访问，如果读取到数据，那么直接返回，如果没有读取到，那么从检查数据库并更新缓存记录。如果数据库里没有记录，那么先调用一个失效操作，然后写入缓存。整个系统看着没什么问题，但是天有不测风云～～～</p>

<!--more-->


<p>现在看看我们的系统问题出在哪里，大胆假设，小心求证后，我发现我们的数据只写了缓存，并没有写到数据库记录。现在来还原案发现场：</p>

<ul>
<li>[1] 集群A和B都没有记录。</li>
<li>[2] 集群A选中，没有记录，写入记录。</li>
<li>[3] 集群A选中，读取记录成功。</li>
<li>[4] 集群A选中，&hellip;&hellip;</li>
<li>[5] 集群B选中，写入A中的记录读取不到（因为2个集群是相互独立的，而且我们只写缓存，所以没有从数据库读取更新缓存这一步），写入之前调用了一次失效操作，导致集群A的记录也失效，这时B集群记录写入。</li>
<li>[6] 集群B选中，读取记录成功。</li>
<li>[7] 集群B选中，&hellip;&hellip;</li>
<li>[8] 集群A选中，第5步的情况又出现了。</li>
</ul>


<p>每次状况5和8出现的时候，因为该读的缓存记录我们没有读取到，所以做了一个特定的操作。然后因为我们应用的访问量特别大，这个操作出现的次数也忒多了些，然后就悲剧了。</p>

<p>最后怎么解决的？代码一行没改，缓存配置为双机房单集群，只要记录写入了缓存就不存在两个机房不一致的问题。所以使用缓存，特别是分布式缓存，有没有持久化记录对于保证记录一致性的影响还是很重要的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式 结构型：适配器]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/08/12/dp-structural-adapter/"/>
    <updated>2014-08-12T20:39:40+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/08/12/dp-structural-adapter</id>
    <content type="html"><![CDATA[<h3>适配器 Adapter</h3>

<p><strong>定义</strong></p>

<p>Wiki<a href="http://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">链接</a>。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类别自己的接口包裹在一个已存在的类中。</p>

<!--more-->


<p>这个简单来说就像Mac接显示器需要一个额外的转接头一样，这个转接头扮演的就是适配器的角色。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Monitor</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">monitor_display</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Monitor display.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Adapter</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">display</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">_monitor</span><span class="p">.</span><span class="n">monitor_display</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Monitor</span> <span class="n">_monitor</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Mac</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">display</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">_adapter</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Adapter</span> <span class="n">_adapter</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Mac</span> <span class="n">mac</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">mac</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[James Bach的Rapid Test培训总结]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/07/31/james-bach-rapid-test/"/>
    <updated>2014-07-31T20:41:01+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/07/31/james-bach-rapid-test</id>
    <content type="html"><![CDATA[<p>首先感谢阿里巴巴邀请James大神在北京办公室组织了Rapid Test的培训。本来报名的目的只是想和兄弟部门的同事找机会一起交流交流，对测试本身并没有抱太大的期望。结果课程开始之后，只能说不服不行。另外，哥活生生的被大神当作了教学道具&hellip;</p>

<p>虽然James大神脱离项目一线专注培训很多年了，而且也没有互联网项目经验，但是一上来就抓住了问题的本质，项目需求不清楚，进度紧张，资源有限，这都是当年项目情况活生生的写照啊！所谓的Rapid Test就是针对这些问题的。为什么这里不说敏捷Agile？因为这里只谈测试，而且谈的是普遍真理，不管你用Agile还是瀑布流，测试都必须解决的一些共性问题。</p>

<!--more-->


<p>培训过程就不具体描述了，这里就谈几点总结：</p>

<ul>
<li>如何挖掘需求。在阿里测试人员经常听到开发人员说：这个功能做好了，你测一下，明天就发了。呃&hellip;好像这个到底是个什么样的功能都没搞清楚。所以对于测试人员要先了解这个系统，它的功能和设计目标。在教学中举了一个真实的例子，系统看着很简单，输入->判断->输出。一开始觉得这个系统简单，但是在得知是针对航天工程设计的系统时，实时性和稳定性就成为了重要的测试需求。在了解了输入系统的复杂程度之后，测试的重点也立刻明确了。所以对于测试人员，一边要自己摸索，同时也要和团队的其它成员密切沟通，获取需要的各种信息帮助决策。</li>
<li>关于测试用例。James基本上否定了测试用例的价值，这点和我们团队内部正在摸索的实践类似。从项目实践的角度来说，光凭借测试用例，我们无法</li>
<li>评估测试的有效性</li>
<li>保持测试用例和实际情况同步（谁不服自己上Kelude看）</li>
<li>从测试用例无法了解整个系统（测试评审基本是在过流水）。
大神的观点是基于场景做测试，你可以不写测试用例，但是不代表你不需要做你的家庭作业。取代测试用例的是如下的报告：</li>
<li>测试场景</li>
<li>每个场景需要覆盖的功能点</li>
<li>对于每个功能点如何测试</li>
<li>场景设计的理由</li>
<li>重点测试模块的选择等。
总儿言之，你必须让项目组成员相信你的测试是完整的，有足够覆盖的，能保证产品质量的。</li>
<li>探索性测试不是无目的的。探索意味着自由，自由意味着责任。因为你能负责，所以才给你一定的自由。你必须通过试探，分析，验证这个流程去深入了解产品，之后再去系统的分析，有针对性的设计测试，这样才是真正的探索性测试。探索不是漫无目的的随机布朗运动，而是要通过探索建立对整个产品的了解。</li>
<li>为什么课程叫Rapid而不是Agile敏捷？因为Rapid Test讲的是普遍真理，不管你用什么开发模式，敏捷或者传统的瀑布流都能解决问题。其实说到底，就是在人手有限，时间有限的情况下找到一个最好的平衡点，既能按时交付，又能保证质量。</li>
<li>测试人员的定位是守门员，是守住产品质量底线的人。这个观点不是很赞同，毕竟当代足球守门员还担负有后场防守组织的责任。个人认为当代软件测试还承担有带领团队保证软件质量以及不断改进质量的责任。</li>
<li>测试的第一要素是人，工具只是辅助。当人们在谈自动化测试的时候，有人要求过开发自动化编程吗？但是事实上，自动化编程某种程度上确实在发生，比如编译器的工作。对于自动化，我们的衡量标准是生产效率的提高和投入产出比。这个是值得我们在日常工作中借鉴的，有时候比起高大上的全自动化测试脚本，手工测试辅助工具更能提高效率，而且维护成本更低，投入产出比更高。</li>
</ul>


<p>课程只有短短两天，要是指望培训后能力有个突飞猛进那是没可能的。这个课程让你回到测试的原点，解答了为什么要做软件测试，如何做软件测试，如何像一个测试工程师一样思考问题，如何去发现问题。把这些原则与你工作实践想结合，才能真正的提高软件产品质量。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015阿里校招內推]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/07/14/2015a-li-xiao-zhao-nei-tui/"/>
    <updated>2014-07-14T13:50:58+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/07/14/2015a-li-xiao-zhao-nei-tui</id>
    <content type="html"><![CDATA[<p>阿里巴巴2015校招內推已经开始了，收到简历的同学我已录入系统，名单如下，大家可以自己对一下。如果有漏掉的，请直接在微博上@我。如果内部推荐电面不通过的话，抱着不落下任一个优秀同学的心态，针对于内部推荐面试不通过的同学，我们还会给予正常校招的笔试机会，笔试通过依然可以参加现场的面试哈。另外，关于內推后的流程，安排如下：</p>

<ul>
<li>即日起至8月1日前完成推荐的简历：简历筛选通过者->安排电话面试</li>
<li>8月1日至8月15日完成推荐的简历：笔试通过者->安排进校面试</li>
<li>8月15日之后完成推荐的简历：我们将在有补招需求时处理</li>
</ul>


<!--more-->


<h4>同学名单</h4>

<p>曹昱：大连理工大学／本科<br/>
陈峰：东南大学／硕士<br/>
陈琼：湖南大学／硕士<br/>
丁道贤：天津大学／硕士<br/>
丁富刚：中南民族大学／本科<br/>
郭婉：西北工业大学／硕士<br/>
李志欣：西北工业大学／硕士<br/>
黄帅：中国地质大学／本科<br/>
刘德强：南阳理工学院／本科<br/>
张友谊：南阳理工学院／本科<br/>
王伟：南京邮电大学／硕士<br/>
王玉萍：南京理工大学／硕士<br/>
吴康伟：山东科技大学／本科<br/>
杨沛超：北京航空航天大学／硕士<br/>
张睿阳：浙江大学／硕士<br/>
徐勤劼：浙江工业大学<br/>
柯姣：宁波大学／硕士<br/>
祝军：宁波大学／硕士<br/>
李木军：宁波大学／硕士<br/>
曹茵茵：北京理工大学／硕士<br/>
李贺：中国科技大学／硕士<br/>
王磊：东华大学／硕士<br/>
王梦丝：西安电子科技大学／硕士<br/>
刘宝：大连理工大学／硕士<br/>
王秀林：大连理工大学／硕士<br/>
姚淑慧：四川大学／本科<br/>
冯博炜：广东工业大学／硕士<br/>
胡为：湖南大学／硕士<br/>
刘斌：湖南大学／硕士<br/>
李中坤：湖南大学／本科<br/>
黄晋：中山大学／本科<br/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式 结构型：外观]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/07/03/dp-structural-facade/"/>
    <updated>2014-07-03T21:22:17+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/07/03/dp-structural-facade</id>
    <content type="html"><![CDATA[<h3>外观 Facade</h3>

<p><strong>定义</strong></p>

<p>Wiki<a href="http://zh.wikipedia.org/zh-cn/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F">链接</a>。它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。</p>

<!--more-->


<p>这个模式估计是所有设计模式里最简单的了。我们以计算机为例，一个开机动作涉及到CPU启动，硬盘读取，内存装载等一系列动作，但是对于用户来说，只要按一下电源键就可以了。我们可以把开机抽象成计算机对象的一个方法，为了完成一次开机，它完成了所有涉及CPU、内存和硬盘的相关操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">CPU</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">freeze</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CPU freeze&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="n">jump</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CPU jump&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="n">execute</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CPU execute&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Memory</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">load</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Memory load&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">HardDisk</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">read</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;HardDisk read&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Computer</span> <span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">CPU</span> <span class="n">cpu</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Memory</span> <span class="n">memory</span><span class="p">;</span>
</span><span class='line'>  <span class="n">HardDisk</span> <span class="n">hard_disk</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">power_on</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">cpu</span><span class="p">.</span><span class="n">freeze</span><span class="p">();</span>
</span><span class='line'>    <span class="n">hard_disk</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
</span><span class='line'>    <span class="n">memory</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Computer power on&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Computer</span> <span class="n">computer</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">computer</span><span class="p">.</span><span class="n">power_on</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式 创建型：单例]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/06/10/dp-creational-singleton/"/>
    <updated>2014-06-10T21:10:19+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/06/10/dp-creational-singleton</id>
    <content type="html"><![CDATA[<h3>单例 Singleton</h3>

<p><strong>定义</strong></p>

<p>Wiki<a href="http://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">链接</a>。单例对象的类必须保证只有一个实例存在。</p>

<!--more-->


<p>为什么需要单例，其实理由很简单，为避免重复建设。比如我们前面讲到的工厂模式，相同的工厂只要有一个就够了，多了就浪费了，管理起来也不方便。下面具体讲一下单例的实现。</p>

<p>实现一（一般面试的标准答案）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">lock</span> <span class="n">g_lock</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Singeleton</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">Obj</span><span class="o">*</span> <span class="n">getInstance</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">_instance</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 加锁确保线程安全</span>
</span><span class='line'>        <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_lock</span><span class="p">);</span>
</span><span class='line'>        <span class="c1">// 这部判断很重要，很有可能其它线程刚调用完getInstance，_instance已被创建。</span>
</span><span class='line'>        <span class="c1">// 如果这里不判断是否NULL，很可能又创建一个新的Obj对象。</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">_instance</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">_instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Obj</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_lock</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">return</span> <span class="n">_instance</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">protected</span><span class="o">:</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">Obj</span> <span class="o">*</span><span class="n">_instance</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">Obj</span><span class="o">*</span> <span class="n">Singeleton</span><span class="o">::</span><span class="n">_instance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>实现二（利用静态变量简化多线程的情况，有兴趣的话可以看下GTest的源码，就是这么做的。）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Singleton</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">T</span><span class="o">*</span> <span class="n">getInstance</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">static</span> <span class="n">T</span> <span class="n">_instance</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">return</span> <span class="o">&amp;</span><span class="n">_instance</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bugs: 价格转换粗大事了]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/05/20/bug-price-convert/"/>
    <updated>2014-05-20T15:12:48+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/05/20/bug-price-convert</id>
    <content type="html"><![CDATA[<p>今天中午刚吃完饭正在一狼假寐，突然电话铃响起！什么？居然有价格为0的商品？立刻从睡梦中惊醒开始排查。啥都不说了，先把肇事代码拿出来：</p>

<!--more-->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">getPriceStr</span><span class="p">(</span><span class="nx">priceLong</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">priceLong</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nx">priceLong</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)).</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>很明显，问题出在round上，丫返回的是整数啊！后台返回的价格单位是分，前台转化成元，想法没错，但是但是&hellip;好吧，测试也有很大责任，只看页面展现，把这个细节漏掉了。从这个例子可以看出，单元测试非常非常重要，如果有单元测试的话，开发阶段就可以把这个问题修复了。还好这次没撞上大活动，在灰度阶段被兄弟部门发现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[算法班学生来信及回复－鸡汤文！]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/05/19/letter-from-student/"/>
    <updated>2014-05-19T21:09:26+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/05/19/letter-from-student</id>
    <content type="html"><![CDATA[<p>在July，Ben，高博老师等一干同志的努力下，上海算法班终于开课了。第一次课比较成功，学生们求知若渴，积极互动。除了算法方面的入门讲座外，也分享了一些职业发展相关的话题。课后，有个同学给我发了消息，经与他确认后，我把这篇文章和我的回复一起贴出来分享一下。</p>

<!--more-->


<p>黑灯老师好，感谢你今天的课程，充满真诚，全是干货。不知道你们出于什么目的办这个课程，因为看起来这些钱对你们来说不算什么。是为了帮助朋友，还是想把培训做大，或者想带出几个不错的学员。从我的角度来讲，这可能会是我花的最值的800块钱。
我先介绍一下自己。我叫XYZ，今年26岁。07年参加高考考入大连理工大学，由于是辽宁人，省内学校的分数线相对低一些，超了录取分数线40多分，去了学校内分数最高的电子信息工程专业。大学期间基本没有把心细放在学习上，GPA只有3.0，后来大三的时候突击英语，申请到了香港大学的授课制研究生。这种研究生基本属于那边吸金的项目，上上课考考试也就毕业了。
自己之前在找工作上也不是特别走心，毕业了以后还gap了将近一年。以前总以为自己有些基本素质，即使不会到企业里再学习。后来发现，企业不是培训机构，找我们来是让我们干活的，让我们创造价值的。父母都在军队工作，也算有些级别，但是对公司上的事就不是很了解，家里不太用我担心，也能帮我找到类似养老国企的工作，不过那些不太是我想要的。自己想真正学点东西，虽然现在水平很差，总归是have to start from somewhere.</p>

<p>上面说了这么多，是想老师对我有个了解，下面问几个问题。
第一、现在感觉处于一种信息很不对等的状态，不知道企业需要什么能力，还有例如这个工作具体每天做什么事情，是不是我想要的。欢迎老师分享一些你工作的经历，对职位发展、行业发展的理解。</p>

<p>第二、就是硬实力这一块。针对面试是一种准备，另外就是真正把我的实力提升起来，肚子里有货。怎么把技术学习好，也都知道多写多看多思考，可是具体做起来就没了方向。比如算法重要还是其他的哪个部分重要，如果算法重要，有哪些具体的提升方法，比如想看MIT算法课程，听你们的课程，刷leetcode这种。看了我自己的介绍，老师估计也知道我是比较懒、比较贪玩的那种，期待找到什么捷径。现在是不想走弯路的多一些，如果有用，我会下决心做好。
还有职业规划这一块。</p>

<p>我是想做一些类似业务、技术、管理、和客户打交道这种交叉综合似的工作，企业可能想找一些外企，国内一些企业，比如百度它的一些做法我不是很认同。不过本身对外企不是很了解，这大多可能是一种叶公好龙的状态。欢迎老师分享见解。</p>

<p>期待进一步跟你们的交流。</p>

<p>&mdash;&mdash;&mdash; 分割线下面是我的回答 &mdash;&mdash;&mdash;</p>

<p>首先你的学历背景已经胜过大多数同龄人了，家庭背景又足以让你没有后顾之忧，所以趁着年轻，赶紧努力去追逐梦想！下面逐条回答你的问题，希望能对你有所帮助。</p>

<ul>
<li><p>关于工作经历什么的建议你上Linkedin，可以查到很多牛人的经历。我的经历没什么特别的，先在国营工厂，然后去了外企，最近又来到了民企。对于职业发展，我有一句忠告：大多数人的工作都是乏味无趣的。如果想追求有挑战性的工作，第一件事诚实的问一下自己能力够不够？所以不要轻视你手里乏味的工作，有个关于年轻人贴发票的段子（不清楚的话可以Google）老得不能再老，但是对现实生活有着切实得指导意义。如果你觉得工作枯燥，乏味，那么运用你的智慧去改善它，让它变得更有趣，更有挑战力。另外对于刚参加工作的年轻人来说，不要指望有什么伯乐，在你证明你的能力之前没人把你当回事。当你一迈上工作岗位后，忘记你的学校和学历，在点滴工作中证明自己才是最好的办法。古人说得好，不积珪步无以成千里，很多业内大牛也都是从很多很初级的工作做起。比如上海微软不少人转到美国去工作，他们在加入微软之前已经是业务骨干，不少在网上也小有名气，但是来了微软后有的做的是很基础的修复一些老产品bug的工作，但正是慢慢的在这些项目上证明能力和建立信任，才逐步转到核心产品岗位上。</p></li>
<li><p>关于企业具体想要什么能力，最简单的方法是看企业招聘广告上的JD（工作描述）。或者是通过社交网络结识相关企业的员工了解详细情况。但是某些能力是通用的：了解计算机体系结构，基本的数据结构和算法，至少熟悉一门编程语言，深入了解1到2样主流技术。</p></li>
<li><p>关于真正的实力，只能说你们很幸运的生在了这个年代。互联网行业与传统行业不同，哪怕你一天班都没上过，也能积累很多经验并证明。想进入大公司，算法只是一方面，很多人不懂算法也混得很好，因为有真本事。但是真本事是需要花时间积累的，比如github上有很多开源项目，可以先试着去读他们的代码，在自己机器上调试，理解了别人的设计后再自己试着去改。说实话，捷径真的没有。我有个朋友，本科毕业加入阿里，4年就升到技术专家，无它，刻苦而已。本科的时候为ACM通宵刷题，工作后为解决技术难题加班到凌晨是经常的。只有热爱并为之真正付出才会有回报。最后给出一个勉强算是捷径的方法：好学校毕业，或者在微博上和很多真伪大牛打得火热，自己的努力达到能和这些人交流的门槛，然后就混圈子吧。</p></li>
<li><p>关于你的职业理想，一开始不会有这样的工作等着你。至少在技术或业务某一个地方证明你的能力，上级才会扩大你的职责范围。今天下午开年会，分管的高级副总裁讲话，他在转向管理之前做了7年的技术工作。我之前有个同事是微软中国的首席技术布道师（从工作内容上来看接近你的要求），但是他在加入微软之前就已经国内出色的技术专家，之后在技术支持和项目管理岗位上又做了10年，没有这点积累，上级和客户怎么会信任你？无论如何，IT行业的萝卜干饭不用像传统行业吃那么久。当年我在国企第一年还是助理工程师，第二年也只是有资格考工程师职称，而且离开那个行业后，你积累的知识毫无用处。另外不管外企民企，干活最重要。很多外企外表光鲜，但本质就是一个大号国企。加入一个公司之前首先问你自己想从里面得到什么。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode终于刷完了]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/05/13/leetcode/"/>
    <updated>2014-05-13T21:33:45+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/05/13/leetcode</id>
    <content type="html"><![CDATA[<p>当年准备面试FLAG时开工的，后来断断续续做了一点，这次终于痛下决心刷完整理上传到github上了。参考链接：<a href="https://github.com/yingl/leetcode_in_cpp">https://github.com/yingl/leetcode_in_cpp</a></p>

<!--more-->


<p>总的来说，这些题目比起专业的ACM还是比较简单的，数据结构不外乎数组，链表和二叉树；算法不外乎二分，递归，回溯，深度／广度优先遍历，空间换时间。到9月份校园招聘季节就开始了，如果对自己算法数据结构不自信的话，那就把这当作一个福利吧！</p>

<p>关于面试的时候为什么要考白板编程，好好参考一下这篇文章：<a href="http://blog.jobbole.com/65625/">白板与编程面试：为什么不在电脑上编程更有帮助</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2014年阿里巴巴实习生面试武汉站总结]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/04/28/wuhan-interview/"/>
    <updated>2014-04-28T18:59:08+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/04/28/wuhan-interview</id>
    <content type="html"><![CDATA[<p>4月24、25两天奔赴武汉参加了2014年阿里巴巴实习生面试，感触不少，写下来和大家分享一下，希望今年找工作的学生能借鉴一二。</p>

<!--more-->


<h3>简历</h3>

<p>最怕看到那种花里胡哨，制作特精美的简历。看了大半天我知道你喜欢摄影，爱好文艺，心地善良，但到底你学过那些课程，做过哪些项目，擅长哪些技术，e&hellip; 看到第三页才发现非常精简的两句话带过了。好的简历只需要一页纸就可以了，最多两页。字体选用标准的宋体或楷体，千万不要打印卡通图案，某同学的大黄鸭给我印象深刻，直到我飞机回上海还惦记着！内容直奔主题，姓名、学校、专业、成绩、擅长技术再加上项目经验。什么个人爱好，自我评价能省就省，就算加也不要超过一行，基本不大有人会关心这些东西，因为面试和你聊的时候都会挖掘出来。</p>

<h3>自我介绍</h3>

<p>虽然看过了简历，但还是想听下自我介绍，主要是想考核一下表达能力。有些同学上来很生猛，姓名学校一报，第三句话就是“简历上都有”。或者就是滔滔不绝，学生会、演讲比赛这些事全说上。好的自我介绍控制在两三分钟左右，重点放在项目和擅长技术上，让面试官明白你在项目里做了什么，克服什么困难，取得什么成果。最好面试前预热一下，好的表达可以留下一个好印象。</p>

<h3>成绩／专业</h3>

<p>大家好好读书吧，我看到最差的也是985学校排名前30%，大多数都是排前10%。不要相信高分低能的说法，真实情况是高分高能的概率更大一点，你是特例的概率比较低。至于非计算机专业的同学也不用担心，只要通过笔试，大家的机会是均等的。计算机这个东西基本靠自学，多看书，多实践，水平自然上去了。</p>

<h3>基础知识</h3>

<p>这个怎么强调都不过分。等工作后发现这些东西离你其实并不遥远，每天都会接触。常用的数据结构、算法、并发资源竞争等，每天的工作都会用到。另外如果是做Java的，GC、反射这些东西得能讲清楚。做C++，this指针，虚函数这些知识要清楚。</p>

<h3>开发 vs 测试</h3>

<p>很多同学有个误区，认为是做不了开发才来做测试，实际上我这里的面试标准是你得先达到开发的要求，我再来和你谈测试的问题（我同时还面C++背景的开发同学）。因为好的测试人员必须是一个好的开发人员，不然他怎么领会代码背后的真实意图？怎么看出设计的问题？怎么分析导致bug的原因？怎么通过改进代码来避免bug而不是被动的等待测试执行时发现bug？我在面试的时候给开发／测试的同学是同一套问题，编程数据结构只用到了数组，最后代码不超过20行，但很多同学还是不能很好的完成（想想哪些遇到链表、二叉树的同学怎么办？）。</p>

<h3>项目经验</h3>

<p>“我负责整个项目的组织协调工作”。这个，我只能说我们这次不招PM。不过就算负责组织协调工作，要是你能1234有条有理讲清楚的话，还是会想办法让你面试过的。还有很多同学的问题是做了什么讲不清楚，或者没有条理。有一个做云存储的同学是个很正面的例子，取得什么成果，用了什么技术，解决了什么困难条理清晰。正好遇到我以前也是做类似产品，问了一些以前遇到的难题，虽然回答不完全正确，但显然是真刀真枪操练过的，对自己方案的弱点一清二楚。所以同学们在平时做项目的时候多思考，多总结。</p>

<p>另外，面试的时候打扮得精神一点会有额外加分，大部分人都是外貌协会的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bugs: 小心Macro]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/04/16/bug-macro/"/>
    <updated>2014-04-16T20:24:59+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/04/16/bug-macro</id>
    <content type="html"><![CDATA[<p>以前在微软做数据库连接组件测试时曾遇到这么一个问题，为了提高测试的真实性，所有测试用例在编译时取消了_DEBUG/DEBUG的定义，结果在执行测试用例的时候出现一个从未见过的错误，经调试发现if/else工作不正常，在if已经判断为false之后还是继续执行，没有跳转。经过对代码反复排查，最终发现是宏的不恰当使用导致了这个问题。</p>

<!--more-->


<p>先看以下这段简化过的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#ifdef _DEBUG</span>
</span><span class='line'>  <span class="err">#</span><span class="n">define</span> <span class="n">TRACE</span> <span class="n">printf</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>  <span class="err">#</span><span class="n">define</span> <span class="n">TRACE</span> <span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">printf</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码初看没什么问题，如果_DEBUG打开TRACE就执行printf，否则TRACE就是一个空操作。但是情况真的跟想当然一样吗？请看以下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define _DEBUG</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#ifdef _DEBUG</span>
</span><span class='line'>  <span class="err">#</span><span class="n">define</span> <span class="n">TRACE</span> <span class="n">printf</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>  <span class="err">#</span><span class="n">define</span> <span class="n">TRACE</span> <span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">printf</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="n">TRACE</span><span class="p">(</span><span class="s">&quot;OK!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Why?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>分别打开关闭<em>DEBUG编译执行看看结果是什么？会不会觉得比较奇怪？如果我把#define </em>DEBUG注释掉，理论上应该什么都不打印。其实这个问题我们只要把宏展开就可以发现，代码其实是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;OK!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Why?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>修复这个问题的方法有两个：</p>

<ul>
<li>在所有调用TRACE的地方用{}包起来，这个改动量太大了，最后没有采用。</li>
<li>用while取代if，这样展开就没有问题了。而且只要修改一个公共的头文件就可以了。</li>
</ul>


<p>最终代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#ifdef _DEBUG</span>
</span><span class='line'>  <span class="err">#</span><span class="n">define</span> <span class="n">TRACE</span> <span class="n">printf</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>  <span class="err">#</span><span class="n">define</span> <span class="n">TRACE</span> <span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">printf</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面例子的代码展开就可以按照期望运行了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;OK!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Why?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式 创建型：原型]]></title>
    <link href="http://blog.monstersay.cn/blog/2014/04/16/dp-creational-prototype/"/>
    <updated>2014-04-16T01:53:44+08:00</updated>
    <id>http://blog.monstersay.cn/blog/2014/04/16/dp-creational-prototype</id>
    <content type="html"><![CDATA[<h3>原型 Prototype</h3>

<p><strong>定义</strong></p>

<p>Wiki<a href="http://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">链接</a>。通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p>

<!--more-->


<p><strong>用户场景</strong></p>

<p>Wiki已经讲的很清楚了。简单来说就是把一个复杂的对象创建过程简化成复制粘贴的形式。需要注意的是我们在复制原型的时候使用深拷贝还是浅拷贝。此外该模式还经常和工厂模式一起使用，因为原型可以用工厂来构建。看了以下例子后可能会有一个疑问，为什么要提供一个clone方法，而不是直接调用拷贝构造函数？因为C++是静态语言，我们在复制原型时并不知道它是具体那个类型，而clone的话这个类自己负责拷贝，只需要返回一个基类类型的指针就可以了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Prototype</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="n">Prototype</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Product</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Prototype</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Product</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Take long time to create a product.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Product</span><span class="p">(</span><span class="k">const</span> <span class="n">Product</span><span class="o">&amp;</span> <span class="n">product</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Copy a product is so fast.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Prototype</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="k">new</span> <span class="n">Product</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Prototype</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Product</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Prototype</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">();</span>
</span><span class='line'>  <span class="n">Prototype</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
</feed>
